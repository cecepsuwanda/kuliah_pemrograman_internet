\section{Web Workers dan Performance}

HTML5 memperkenalkan Web Workers untuk menjalankan JavaScript di background thread, memungkinkan aplikasi web yang responsif dan performant. Performance APIs menyediakan tools untuk mengukur dan mengoptimasi kinerja aplikasi \cite{mdn-web-workers}. Kombinasi Web Workers dan Performance APIs membuka kemungkinan untuk aplikasi web yang kompleks tanpa blocking main thread \cite{w3schools-html}.

\subsection{Web Workers Basics}

Web Workers memungkinkan eksekusi JavaScript di thread terpisah dari main thread:

\begin{itemize}
  \item \textbf{Dedicated Workers}: Worker yang terhubung ke satu script
  \item \textbf{Shared Workers}: Worker yang dapat diakses oleh multiple scripts
  \item \textbf{Service Workers}: Workers untuk caching dan offline functionality
  \item \textbf{Communication}: Message passing antara main thread dan worker
  \item \textbf{Limitations}: Tidak ada akses ke DOM, window, atau document
\end{itemize}

\begin{lstlisting}[caption={Web Workers Implementation}, basicstyle=\ttfamily\small, frame=single]
<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Workers Demo</title>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f8f9fa; }
    .worker-demo { background-color: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .btn { background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin-right: 10px; margin-bottom: 10px; }
    .btn:hover { background-color: #0056b3; }
    .btn:disabled { background-color: #6c757d; cursor: not-allowed; }
    .progress-container { width: 100%; height: 20px; background-color: #e9ecef; border-radius: 10px; overflow: hidden; margin: 15px 0; }
    .progress-bar { height: 100%; background-color: #28a745; width: 0; transition: width 0.3s; }
    .result-container { background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 15px; margin-top: 15px; max-height: 200px; overflow-y: auto; }
    .status { padding: 10px; border-radius: 4px; margin-top: 10px; }
    .status.running { background-color: #fff3cd; color: #856404; }
    .status.completed { background-color: #d4edda; color: #155724; }
    .status.error { background-color: #f8d7da; color: #721c24; }
    .comparison-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>üöÄ Web Workers Demo</h1>
  
  <!-- Heavy Computation Demo -->
  <div class="worker-demo">
    <h2>üî¢ Heavy Computation (Prime Numbers)</h2>
    
    <div class="comparison-grid">
      <div>
        <h3>Main Thread (Blocking)</h3>
        <div>
          <label>Calculate primes up to:</label>
          <input type="number" id="mainLimit" value="100000" min="1000" max="1000000" style="width: 100%; padding: 8px; margin: 5px 0;">
        </div>
        <button class="btn" onclick="calculatePrimesMain()" id="mainBtn">Calculate on Main Thread</button>
        
        <div class="progress-container">
          <div class="progress-bar" id="mainProgress"></div>
        </div>
        
        <div id="mainStatus" class="status" style="display: none;"></div>
        <div id="mainResult" class="result-container" style="display: none;"></div>
      </div>
      
      <div>
        <h3>Web Worker (Non-blocking)</h3>
        <div>
          <label>Calculate primes up to:</label>
          <input type="number" id="workerLimit" value="100000" min="1000" max="1000000" style="width: 100%; padding: 8px; margin: 5px 0;">
        </div>
        <button class="btn" onclick="calculatePrimesWorker()" id="workerBtn">Calculate with Web Worker</button>
        
        <div class="progress-container">
          <div class="progress-bar" id="workerProgress"></div>
        </div>
        
        <div id="workerStatus" class="status" style="display: none;"></div>
        <div id="workerResult" class="result-container" style="display: none;"></div>
      </div>
    </div>
    
    <div style="background-color: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 4px; padding: 15px; margin-top: 20px;">
      <h4>üìù Notice:</h4>
      <p><strong>Main Thread:</strong> UI akan freeze saat perhitungan berlangsung</p>
      <p><strong>Web Worker:</strong> UI tetap responsif karena perhitungan di background thread</p>
      <p><strong>Try this:</strong> Klik "Calculate on Main Thread" dan coba klik button lain selama perhitungan</p>
    </div>
  </div>
  
  <!-- UI Responsiveness Test -->
  <div class="worker-demo">
    <h2>üé® UI Responsiveness Test</h2>
    
    <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 15px;">
      <div style="width: 50px; height: 50px; background-color: #007bff; border-radius: 50%; animation: pulse 2s infinite;"></div>
      <p>Animation ini akan freeze saat main thread sibuk</p>
    </div>
    
    <div style="background-color: #f0f0f0; padding: 20px; border-radius: 8px; margin: 10px 0;">
      <p>Counter: <span id="counter" style="font-size: 24px; font-weight: bold; color: #007bff;">0</span></p>
      <button class="btn" onclick="incrementCounter()">Increment Counter</button>
    </div>
    
    <style>
      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.2); }
      }
    </style>
  </div>
  
  <!-- Worker Code (normally in separate file) -->
  <script id="workerCode" type="javascript/worker">
    self.onmessage = function(e) {
      const limit = e.data.limit;
      const primes = [];
      
      for (let i = 2; i <= limit; i++) {
        let isPrime = true;
        for (let j = 2; j <= Math.sqrt(i); j++) {
          if (i % j === 0) {
            isPrime = false;
            break;
          }
        }
        
        if (isPrime) {
          primes.push(i);
        }
        
        // Send progress update every 1000 numbers
        if (i % 1000 === 0) {
          self.postMessage({
            type: 'progress',
            progress: Math.round((i / limit) * 100),
            current: i,
            limit: limit
          });
        }
      }
      
      self.postMessage({
        type: 'complete',
        primes: primes,
        count: primes.length
      });
    };
  </script>
  
  <script>
    let worker = null;
    let counter = 0;
    
    // Calculate primes on main thread (blocking)
    function calculatePrimesMain() {
      const limit = parseInt(document.getElementById('mainLimit').value);
      const mainBtn = document.getElementById('mainBtn');
      const mainProgress = document.getElementById('mainProgress');
      const mainStatus = document.getElementById('mainStatus');
      const mainResult = document.getElementById('mainResult');
      
      mainBtn.disabled = true;
      mainStatus.className = 'status running';
      mainStatus.textContent = 'Calculating on main thread... UI will freeze';
      mainStatus.style.display = 'block';
      mainResult.style.display = 'none';
      
      // Use setTimeout to allow UI to update before blocking
      setTimeout(() => {
        const startTime = performance.now();
        const primes = [];
        
        for (let i = 2; i <= limit; i++) {
          let isPrime = true;
          for (let j = 2; j <= Math.sqrt(i); j++) {
            if (i % j === 0) {
              isPrime = false;
              break;
            }
          }
          
          if (isPrime) {
            primes.push(i);
          }
          
          // Update progress every 1000 numbers
          if (i % 1000 === 0) {
            mainProgress.style.width = Math.round((i / limit) * 100) + '%';
          }
        }
        
        const endTime = performance.now();
        const duration = (endTime - startTime).toFixed(2);
        
        mainProgress.style.width = '100%';
        mainStatus.className = 'status completed';
        mainStatus.textContent = `Completed in ${duration}ms - Found ${primes.length} primes`;
        
        mainResult.innerHTML = `
          <h4>Results:</h4>
          <p><strong>Duration:</strong> ${duration}ms</p>
          <p><strong>Primes found:</strong> ${primes.length}</p>
          <p><strong>First 10 primes:</strong> ${primes.slice(0, 10).join(', ')}</p>
          <p><strong>Last 10 primes:</strong> ${primes.slice(-10).join(', ')}</p>
        `;
        mainResult.style.display = 'block';
        mainBtn.disabled = false;
        
      }, 100);
    }
    
    // Calculate primes with Web Worker (non-blocking)
    function calculatePrimesWorker() {
      const limit = parseInt(document.getElementById('workerLimit').value);
      const workerBtn = document.getElementById('workerBtn');
      const workerProgress = document.getElementById('workerProgress');
      const workerStatus = document.getElementById('workerStatus');
      const workerResult = document.getElementById('workerResult');
      
      workerBtn.disabled = true;
      workerStatus.className = 'status running';
      workerStatus.textContent = 'Calculating with Web Worker... UI remains responsive';
      workerStatus.style.display = 'block';
      workerResult.style.display = 'none';
      workerProgress.style.width = '0%';
      
      const startTime = performance.now();
      
      // Create worker from inline script
      const workerScript = document.getElementById('workerCode').textContent;
      const blob = new Blob([workerScript], { type: 'application/javascript' });
      worker = new Worker(URL.createObjectURL(blob));
      
      worker.onmessage = function(e) {
        const data = e.data;
        
        if (data.type === 'progress') {
          workerProgress.style.width = data.progress + '%';
          workerStatus.textContent = `Progress: ${data.progress}% (${data.current}/${data.limit})`;
        } else if (data.type === 'complete') {
          const endTime = performance.now();
          const duration = (endTime - startTime).toFixed(2);
          
          workerProgress.style.width = '100%';
          workerStatus.className = 'status completed';
          workerStatus.textContent = `Completed in ${duration}ms - Found ${data.count} primes`;
          
          workerResult.innerHTML = `
            <h4>Results:</h4>
            <p><strong>Duration:</strong> ${duration}ms</p>
            <p><strong>Primes found:</strong> ${data.count}</p>
            <p><strong>First 10 primes:</strong> ${data.primes.slice(0, 10).join(', ')}</p>
            <p><strong>Last 10 primes:</strong> ${data.primes.slice(-10).join(', ')}</p>
          `;
          workerResult.style.display = 'block';
          workerBtn.disabled = false;
          
          // Terminate worker
          worker.terminate();
          worker = null;
        }
      };
      
      worker.onerror = function(error) {
        workerStatus.className = 'status error';
        workerStatus.textContent = 'Error: ' + error.message;
        workerBtn.disabled = false;
      };
      
      // Send message to worker
      worker.postMessage({ limit: limit });
    }
    
    // Increment counter
    function incrementCounter() {
      counter++;
      document.getElementById('counter').textContent = counter;
    }
    
    // Auto-increment counter to show UI responsiveness
    setInterval(() => {
      counter++;
      document.getElementById('counter').textContent = counter;
    }, 1000);
  </script>
</body>
</html>
\end{lstlisting}

\textbf{Hasil di Browser:}
- Side-by-side comparison: Main Thread vs Web Worker untuk heavy computation
- Progress bar yang updates secara real-time untuk kedua metode
- UI responsiveness test dengan animasi dan counter
- Web Worker menjalankan perhitungan di background tanpa blocking UI
- Performance metrics showing duration dan jumlah primes found

\subsection{Performance APIs}

Performance APIs menyediakan tools untuk mengukur dan mengoptimasi kinerja aplikasi:

\begin{itemize}
  \item \textbf{Performance Timeline}: Navigation Timing, Resource Timing, User Timing
  \item \textbf{PerformanceObserver}: Monitoring performance metrics secara real-time
  \item \textbf{Memory API}: Monitoring memory usage aplikasi
  \item \textbf{Frame Timing}: Mengukur frame rate dan rendering performance
  \item \textbf{Long Tasks API}: Detecting tasks yang blocking main thread
\end{itemize}

\begin{lstlisting}[caption={Performance APIs Demo}, basicstyle=\ttfamily\small, frame=single]
<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Performance APIs Demo</title>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f8f9fa; }
    .perf-demo { background-color: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px; }
    .metric-card { background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; padding: 15px; text-align: center; }
    .metric-value { font-size: 24px; font-weight: bold; color: #007bff; margin: 10px 0; }
    .metric-label { font-size: 14px; color: #6c757d; }
    .btn { background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin-right: 10px; margin-bottom: 10px; }
    .btn:hover { background-color: #0056b3; }
    .chart-container { background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; padding: 15px; margin-top: 15px; height: 200px; position: relative; }
    .performance-log { background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 15px; margin-top: 15px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; }
  </style>
</head>
<body>
  <h1>‚ö° Performance APIs Demo</h1>
  
  <!-- Navigation Timing -->
  <div class="perf-demo">
    <h2>üåê Navigation Timing</h2>
    
    <button class="btn" onclick="measureNavigationTiming()">üìä Measure Page Load</button>
    <button class="btn" onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
    
    <div class="metrics-grid" id="navMetrics" style="display: none;">
      <div class="metric-card">
        <div class="metric-label">DNS Lookup</div>
        <div class="metric-value" id="dnsTime">-</div>
        <small>Time to resolve domain</small>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">TCP Connection</div>
        <div class="metric-value" id="tcpTime">-</div>
        <small>Time to establish connection</small>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">Response Time</div>
        <div class="metric-value" id="responseTime">-</div>
        <small>Time to first byte</small>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">DOM Processing</div>
        <div class="metric-value" id="domTime">-</div>
        <small>Time to parse DOM</small>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">Load Event</div>
        <div class="metric-value" id="loadTime">-</div>
        <small>Time to load event</small>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">Total Load Time</div>
        <div class="metric-value" id="totalTime">-</div>
        <small>Complete page load</small>
      </div>
    </div>
  </div>
  
  <!-- User Timing API -->
  <div class="perf-demo">
    <h2>‚è±Ô∏è User Timing API</h2>
    
    <button class="btn" onclick="startUserTiming()">‚ñ∂Ô∏è Start Measurement</button>
    <button class="btn" onclick="markCheckpoint()">üìç Mark Checkpoint</button>
    <button class="btn" onclick="endUserTiming()">‚èπÔ∏è End Measurement</button>
    <button class="btn" onclick="showUserTimings()">üìä Show Results</button>
    
    <div class="performance-log" id="userTimingLog" style="display: none;"></div>
  </div>
  
  <!-- Memory API -->
  <div class="perf-demo">
    <h2>üíæ Memory Usage</h2>
    
    <button class="btn" onclick="checkMemory()">üîç Check Memory</button>
    <button class="btn" onclick="createObjects()">üì¶ Create Test Objects</button>
    <button class="btn" onclick="gcHint()">üóëÔ∏è Request GC</button>
    
    <div class="metrics-grid" id="memoryMetrics" style="display: none; margin-top: 15px;">
      <div class="metric-card">
        <div class="metric-label">Used JS Heap</div>
        <div class="metric-value" id="usedHeap">-</div>
        <small>Memory currently in use</small>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">Total JS Heap</div>
        <div class="metric-value" id="totalHeap">-</div>
        <small>Total heap size</small>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">Heap Limit</div>
        <div class="metric-value" id="heapLimit">-</div>
        <small>Maximum heap size</small>
      </div>
    </div>
  </div>
  
  <!-- Frame Timing -->
  <div class="perf-demo">
    <h2>üé¨ Frame Rate Monitor</h2>
    
    <button class="btn" onclick="startFrameMonitoring()">‚ñ∂Ô∏è Start Monitoring</button>
    <button class="btn" onclick="stopFrameMonitoring()">‚èπÔ∏è Stop Monitoring</button>
    
    <div class="metrics-grid" style="margin-top: 15px;">
      <div class="metric-card">
        <div class="metric-label">Current FPS</div>
        <div class="metric-value" id="currentFPS">-</div>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">Average FPS</div>
        <div class="metric-value" id="avgFPS">-</div>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">Dropped Frames</div>
        <div class="metric-value" id="droppedFrames">-</div>
      </div>
    </div>
    
    <div class="chart-container">
      <canvas id="fpsChart" width="800" height="200"></canvas>
    </div>
  </div>
  
  <script>
    // Navigation Timing API
    function measureNavigationTiming() {
      const navigation = performance.getEntriesByType('navigation')[0];
      
      if (!navigation) {
        alert('Navigation Timing API not supported');
        return;
      }
      
      // Calculate timings
      const dnsTime = navigation.domainLookupEnd - navigation.domainLookupStart;
      const tcpTime = navigation.connectEnd - navigation.connectStart;
      const responseTime = navigation.responseStart - navigation.requestStart;
      const domTime = navigation.domComplete - navigation.domLoading;
      const loadTime = navigation.loadEventEnd - navigation.loadEventStart;
      const totalTime = navigation.loadEventEnd - navigation.navigationStart;
      
      // Display metrics
      document.getElementById('dnsTime').textContent = dnsTime + 'ms';
      document.getElementById('tcpTime').textContent = tcpTime + 'ms';
      document.getElementById('responseTime').textContent = responseTime + 'ms';
      document.getElementById('domTime').textContent = domTime + 'ms';
      document.getElementById('loadTime').textContent = loadTime + 'ms';
      document.getElementById('totalTime').textContent = totalTime + 'ms';
      
      document.getElementById('navMetrics').style.display = 'grid';
    }
    
    // User Timing API
    let timingMeasurements = [];
    
    function startUserTiming() {
      performance.mark('start');
      logUserTiming('Measurement started');
    }
    
    function markCheckpoint() {
      const markName = 'checkpoint-' + Date.now();
      performance.mark(markName);
      logUserTiming(`Checkpoint marked: ${markName}`);
    }
    
    function endUserTiming() {
      performance.mark('end');
      performance.measure('total', 'start', 'end');
      logUserTiming('Measurement ended');
    }
    
    function showUserTimings() {
      const measures = performance.getEntriesByType('measure');
      const marks = performance.getEntriesByType('mark');
      
      let log = '<h4>User Timing Results:</h4>';
      
      log += '<h5>Measures:</h5>';
      measures.forEach(measure => {
        log += `<p>${measure.name}: ${measure.duration.toFixed(2)}ms</p>`;
      });
      
      log += '<h5>Marks:</h5>';
      marks.forEach(mark => {
        log += `<p>${mark.name}: ${mark.startTime.toFixed(2)}ms</p>`;
      });
      
      const logContainer = document.getElementById('userTimingLog');
      logContainer.innerHTML = log;
      logContainer.style.display = 'block';
    }
    
    function logUserTiming(message) {
      const logContainer = document.getElementById('userTimingLog');
      const timestamp = new Date().toLocaleTimeString();
      logContainer.innerHTML += `<p>[${timestamp}] ${message}</p>`;
      logContainer.style.display = 'block';
    }
    
    function clearLogs() {
      document.getElementById('userTimingLog').innerHTML = '';
      document.getElementById('userTimingLog').style.display = 'none';
      document.getElementById('navMetrics').style.display = 'none';
    }
    
    // Memory API
    function checkMemory() {
      if (performance.memory) {
        const memory = performance.memory;
        
        document.getElementById('usedHeap').textContent = formatBytes(memory.usedJSHeapSize);
        document.getElementById('totalHeap').textContent = formatBytes(memory.totalJSHeapSize);
        document.getElementById('heapLimit').textContent = formatBytes(memory.jsHeapSizeLimit);
        
        document.getElementById('memoryMetrics').style.display = 'grid';
      } else {
        alert('Memory API not supported in this browser');
      }
    }
    
    function createObjects() {
      // Create some objects to increase memory usage
      const largeArray = [];
      for (let i = 0; i < 100000; i++) {
        largeArray.push({
          id: i,
          data: 'x'.repeat(100),
          timestamp: Date.now()
        });
      }
      
      alert('Created 100,000 test objects. Check memory usage now.');
      checkMemory();
    }
    
    function gcHint() {
      // Hint to browser that GC would be beneficial
      if (window.gc) {
        window.gc();
        alert('Garbage collection requested');
      } else {
        alert('GC not available. Try closing and reopening the page.');
      }
      checkMemory();
    }
    
    function formatBytes(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    // Frame Rate Monitoring
    let frameId = null;
    let frameCount = 0;
    let lastTime = 0;
    let fpsHistory = [];
    
    function startFrameMonitoring() {
      if (frameId) return;
      
      frameCount = 0;
      lastTime = performance.now();
      fpsHistory = [];
      
      measureFrameRate();
    }
    
    function measureFrameRate() {
      frameCount++;
      const currentTime = performance.now();
      const deltaTime = currentTime - lastTime;
      
      if (deltaTime >= 1000) {
        const fps = Math.round((frameCount * 1000) / deltaTime);
        fpsHistory.push(fps);
        
        if (fpsHistory.length > 60) {
          fpsHistory.shift();
        }
        
        document.getElementById('currentFPS').textContent = fps;
        
        const avgFPS = Math.round(fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length);
        document.getElementById('avgFPS').textContent = avgFPS;
        
        // Estimate dropped frames (assuming 60 FPS target)
        const dropped = Math.max(0, 60 - fps);
        document.getElementById('droppedFrames').textContent = dropped;
        
        drawFPSChart();
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      frameId = requestAnimationFrame(measureFrameRate);
    }
    
    function stopFrameMonitoring() {
      if (frameId) {
        cancelAnimationFrame(frameId);
        frameId = null;
      }
    }
    
    function drawFPSChart() {
      const canvas = document.getElementById('fpsChart');
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (fpsHistory.length === 0) return;
      
      // Draw grid
      ctx.strokeStyle = '#e9ecef';
      ctx.lineWidth = 1;
      
      for (let i = 0; i <= 10; i++) {
        const y = (canvas.height / 10) * i;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      
      // Draw FPS line
      ctx.strokeStyle = '#007bff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      const barWidth = canvas.width / fpsHistory.length;
      
      for (let i = 0; i < fpsHistory.length; i++) {
        const fps = fpsHistory[i];
        const x = i * barWidth;
        const y = canvas.height - (fps / 70) * canvas.height;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.stroke();
      
      // Draw target line (60 FPS)
      ctx.strokeStyle = '#28a745';
      ctx.setLineDash([5, 5]);
      const targetY = canvas.height - (60 / 70) * canvas.height;
      ctx.beginPath();
      ctx.moveTo(0, targetY);
      ctx.lineTo(canvas.width, targetY);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Labels
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      ctx.fillText('60 FPS Target', 10, targetY - 5);
      ctx.fillText('FPS History (last 60 seconds)', 10, 20);
    }
  </script>
</body>
</html>
\end{lstlisting}

\textbf{Hasil di Browser:}
- Navigation Timing API showing DNS, TCP, response, DOM processing times
- User Timing API untuk custom performance measurements
- Memory API monitoring untuk heap usage
- Frame rate monitoring dengan real-time FPS chart
- Performance metrics dengan visual indicators

Web Workers dan Performance APIs memberikan tools yang powerful untuk mengukur dan mengoptimasi kinerja aplikasi web \cite{w3schools-html}. Dengan Web Workers, heavy computations dapat dijalankan di background tanpa blocking UI, sementara Performance APIs menyediakan visibility ke dalam setiap aspect dari application performance \cite{mdn-web-workers}.
